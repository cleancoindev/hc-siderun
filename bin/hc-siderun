#!/bin/bash

# AUTO-GENERATED by build/test.bash - do not edit directly

# make bash a little more strict / deterministic
set -Eeuo pipefail

_SR_VERSION_GIT="0ef4e2c"

# -- begin source files -- #


###########################################################################
# version.bash
###########################################################################

_SR_VERSION_MAJ=0
_SR_VERSION_MIN=0
_SR_VERSION_PATCH=1
_SR_VERSION="v${_SR_VERSION_MAJ}.${_SR_VERSION_MIN}.${_SR_VERSION_PATCH}+${_SR_VERSION_GIT}"

###########################################################################
# util.bash
###########################################################################

# helpful utility functions

# logging helper
function _sr_log {
  local _FMT="${1}"
  shift 1
  printf "# hc-siderun: " 1>&2
  printf "${_FMT}\n" "${@}" 1>&2
}

# fatal exit condition
function _sr_fail {
  _sr_log "${@}"
  _sr_log "FATAL ERROR - aborting"
  exit 1
}

###########################################################################
# opt.bash
###########################################################################

# siderun option parsing helper

# print out usage info
function _sr_usage {
  local __CMD="$(basename ${0})"
  echo "usage: ${__CMD} [subcommand] [options]" 1>&2
  echo "       version ${_SR_VERSION}" 1>&2
  echo $'
[subcommands]
 * help    = display this help / usage message

 * version = display version and exit

 * init    = initialize an hc siderun cluster
      -c=<name> --cluster=<name> : the cluster name defaults to "default"
      -p=<path> --path=<path> : required - path to the hc application source

 * list    = list all initialized siderun clusters

 * run     = execute the named siderun cluster
      -c=<name> --cluster=<name> : the cluster name defaults to "default"

 * del     = delete a named siderun cluster
      -c=<name> --cluster=<name> : the cluster name defaults to "default"

 * clean   = clean up, delete all clusters

[environment]
 * HC_SIDERUN_WORK_DIR - default: "$HOME/.hc-siderun"
 * HC_SIDERUN_MAGIC    - default: "hcs.~-~"' 1>&2
  exit 0
}

# @scope-param _SR_O_CMD - sub command
# @scope-param _SR_O_CLUSTER - -c / --cluster
# @scope-param _SR_O_NAME - -n / --name
# @scope-param _SR_O_PATH - -p / --path
function _sr_opt_parse {
  for i in "${@}"; do
    case ${i} in
      -*)
        local __KEY="${i%%=*}"
        local __VAL="${i#*=}"
        if [[ ${__KEY} == -* ]]; then
          local __KEY="${__KEY#*-}"
        fi
        if [[ ${__KEY} == -* ]]; then
          local __KEY="${__KEY#*-}"
        fi
        case ${__KEY} in
          c|cluster)
            if [ "${_SR_O_CLUSTER}x" != "x" ]; then
              _sr_fail \
                "illegal multiple cluster flags '${_SR_O_CLUSTER}' + '${__VAL}'"
            fi
            _SR_O_CLUSTER="${__VAL}"
            ;;
          n|name)
            if [ "${_SR_O_NAME}x" != "x" ]; then
              _sr_fail \
                "illegal multiple name flags '${_SR_O_NAME}' + '${__VAL}'"
            fi
            _SR_O_NAME="${__VAL}"
            ;;
          p|path)
            if [ "${_SR_O_PATH}x" != "x" ]; then
              _sr_fail \
                "illegal multiple path flags '${_SR_O_PATH}' + '${__VAL}'"
            fi
            _SR_O_PATH="${__VAL}"
            _SR_O_PATH="$(readlink -f ${_SR_O_PATH})"
            ;;
          *)
            _sr_fail "unrecognized flag '${__KEY}'"
            ;;
        esac
        ;;
      *)
        if [ "${_SR_O_CMD}x" != "x" ]; then
          _sr_fail "illegal multiple sub-commands '${_SR_O_CMD}' + '${i}'"
        fi
        _SR_O_CMD="${i}"
        ;;
    esac
  done

  if [ "${_SR_O_CMD}x" == "x" -o "${_SR_O_CMD}" == "help" ]; then
    _sr_usage "${@}"
  fi

  if [ "${_SR_O_CMD}" == "version" ]; then
    # print this to stdout
    echo "${_SR_VERSION}"
    exit 0
  fi

  # defaults
  if [ "${_SR_O_CLUSTER}x" == "x" ]; then
    _SR_O_CLUSTER="default"
  fi
}

###########################################################################
# validate.bash
###########################################################################

# validate sanity of environment
function _sr_validate_env {
  if ! ((screen -v || true) | grep 'Screen version' > /dev/null); then
    _sr_fail "Fatal: %s" \
      "'screen' command not found, 'sudo apt-get install screen'?"
  fi

  if ! (bs -v | grep 'bs version' > /dev/null); then
    _sr_fail "Fatal: %s" \
      "'bs' command not found / did you set up your holochain PATH?"
  fi

  if ! (hcdev -v | grep 'hcdev version' > /dev/null); then
    _sr_fail "Fatal: %s" \
      "'hcdev' command not found / did you set up your holochain PATH?"
  fi

  if ! (hcadmin -v | grep 'hcadmin version' > /dev/null); then
    _sr_fail "Fatal: %s" \
      "'hcadmin' command not found / did you set up your holochain PATH?"
  fi
}

###########################################################################
# cmd.init.bash
###########################################################################

# cmd init hc-siderun subcommand implementation

# initialize one node
function _sr_cmd_init_node {
  local __INDEX="${1}"
  local __NAME="node${__INDEX}"
  local __DHT_PORT="$((10100 + ${i}))"
  local __WEB_PORT="$((10000 + ${i}))"
  local __WS=$(mktemp -d -p "${_SR_C_DIR}" \
    -t "${_SR_MAGIC}.${__NAME}.XXXXXXXXXXXXXX")
  echo "screen -t ${__NAME} hcdev --bootstrapServer 127.0.0.1:10000 --execpath ${__WS} --path ${_SR_O_PATH} --DHTport ${__DHT_PORT} --debug web ${__WEB_PORT}" >> "${_SR_SCREEN_RC}"
  hcadmin --path "${__WS}" init "${__NAME}@test.test" > /dev/null 2>&1
}

# execute the 'init' command
# set up a new cluster set
# @scope-param _SR_O_PATH - -p / --path
function _sr_cmd_init {
  if [ "${_SR_O_PATH}x" == "x" ]; then
    _sr_fail "'-p / --path' flag required for 'join' subcommand"
  fi

  local _SR_C_DIR="${_SR_WORK_DIR}/${_SR_O_CLUSTER}"
  if [ -d "${_SR_C_DIR}" ]; then
    _sr_fail "'${_SR_C_DIR}' exists, aborting"
  fi

  mkdir -p "${_SR_C_DIR}"

  local _SR_SCREEN_RC="${_SR_C_DIR}/cluster.screenrc"
  cat << EOF > "${_SR_SCREEN_RC}"
startup_message off
defscrollback 10000

screen -t bootstrap bs --port 10000
EOF

  for i in 1 2 3; do
    _sr_cmd_init_node "${i}"
  done
}

###########################################################################
# cmd.list.bash
###########################################################################

# cmd list hc-siderun subcommand implementation

function _sr_cmd_list {
  for _SR_O_CLUSTER in $(ls "${_SR_WORK_DIR}"); do
    local _SR_C_DIR="${_SR_WORK_DIR}/${_SR_O_CLUSTER}"
    local _SR_SCREEN_RC="${_SR_C_DIR}/cluster.screenrc"
    if [ -d "${_SR_C_DIR}" -a -f "${_SR_SCREEN_RC}" ]; then
      echo "${_SR_O_CLUSTER}"
    fi
  done
}

###########################################################################
# cmd.run.bash
###########################################################################

# cmd run hc-siderun subcommand implementation

_SR_SCREEN_SOCKET_NAME=""
function _sr_cleanup_screen {
  screen -S "${_SR_SCREEN_SOCKET_NAME}" -X quit > /dev/null 2>&1 || true
  screen -wipe > /dev/null 2>&1 || true
}

function _sr_cmd_run {
  local _SR_C_DIR="${_SR_WORK_DIR}/${_SR_O_CLUSTER}"
  if [ ! -d "${_SR_C_DIR}" ]; then
    _sr_fail "'${_SR_C_DIR}' does not exist, aborting"
  fi

  _SR_SCREEN_SOCKET_NAME="${_SR_MAGIC}.${_SR_O_CLUSTER}"

  _sr_cleanup_screen
  trap _sr_cleanup_screen EXIT

  local _SR_SCREEN_RC="${_SR_C_DIR}/cluster.screenrc"
  screen -DmS "${_SR_SCREEN_SOCKET_NAME}" -c "${_SR_SCREEN_RC}" &
  local __PID="${!}"

  _sr_log "Screen is running, ctrl-c to stop it"
  _sr_log "you should be able to 'screen -r' from another terminal"
  _sr_log "pid = ${__PID}"
  _sr_log "\n%s\n%s\n%s" "http://127.0.0.1:10001" "http://127.0.0.1:10002" "http://127.0.0.1:10003"

  wait "${__PID}"
}

###########################################################################
# cmd.del.bash
###########################################################################

# cmd del hc-siderun subcommand implementation

function _sr_cmd_del {
  local _SR_C_DIR="${_SR_WORK_DIR}/${_SR_O_CLUSTER}"
  if [ ! -d "${_SR_C_DIR}" ]; then
    _sr_fail "'${_SR_C_DIR}' does not exist, aborting"
  fi

  rm "${_SR_C_DIR}/cluster.screenrc" > /dev/null 2>&1 || true

  # make cleaning up work dirs a little safer (rm -Rf * yay)
  for __NODE in $(ls "${_SR_C_DIR}"); do
    local __P="${_SR_C_DIR}/${__NODE}"
    if [[ ${__NODE} == "${_SR_MAGIC}"* ]] && [ -d "${__P}" ]; then
      rm -Rf "${__P}"
    fi
  done

  rmdir "${_SR_C_DIR}"
}

###########################################################################
# cmd.clean.bash
###########################################################################

# cmd clean hc-siderun subcommand implementation

function _sr_cmd_clean {
  for _SR_O_CLUSTER in $(ls "${_SR_WORK_DIR}"); do
    local _SR_C_DIR="${_SR_WORK_DIR}/${_SR_O_CLUSTER}"
    local _SR_SCREEN_RC="${_SR_C_DIR}/cluster.screenrc"
    if [ -d "${_SR_C_DIR}" -a -f "${_SR_SCREEN_RC}" ]; then
      _sr_cmd_del
    fi
  done
}

###########################################################################
# main.bash
###########################################################################

# entrypoint for hc-siderun tool

# set up some hc tool environment variables
function _hc_tool_env {
  export HC_DEFAULT_BOOTSTRAPSERVER="127.0.0.1:10000"
  export HCLOG_APP_ENABLE=1
  export HCLOG_DHT_ENABLE=1
  export HCLOG_GOSSIP_ENABLE=1
  export HCLOG_DEBUG_ENABLE=1
}

# siderun main entrypoint
function _sr_main {
  # scope variables for _sr_opt_parse
  local _SR_O_CMD=""
  local _SR_O_CLUSTER=""
  local _SR_O_NAME=""
  local _SR_O_PATH=""

  # parse our options
  _sr_opt_parse "${@}"

  # make sure the commands we need exist
  _sr_validate_env

  # make sure hc tools behave how we want them to
  _hc_tool_env

  # scope variables for commands
  local _SR_WORK_DIR="${HC_SIDERUN_WORK_DIR:-${HOME}/.hc-siderun}"
  local _SR_WORK_DIR="$(readlink -f ${_SR_WORK_DIR})"
  local _SR_MAGIC="${HC_SIDERUN_MAGIC:-hcs.~-~}"

  # delegate to command handlers
  case ${_SR_O_CMD} in
    init)
      _sr_cmd_init
      ;;
    list)
      _sr_cmd_list
      ;;
    run)
      _sr_cmd_run
      ;;
    del)
      _sr_cmd_del
      ;;
    clean)
      _sr_cmd_clean
      ;;
    *)
      _sr_log "unknown command '${_SR_O_CMD}'"
      _sr_usage "${@}"
      ;;
  esac
}

# entrypoint
_sr_main "${@}"
